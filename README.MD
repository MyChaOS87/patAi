# patAi
Hi, and a warm welcome to my task solution. I know this is not the shortest possibility, but I wanted to do at least some layering and separation of code in this example.

## How to run
Run via docker compose: `docker compose up --build`

This starts the service on: `localhost:8080`

After startup, you should be able to access the swagger UI via `http://localhost:8080/api/v0/openapi/ui/index.html`


## Remarks
* API:
  * The OpenAPI specification came first; that is why it is not autogenerated from endpoint annotations.
  * You have to authenticate with an `X-API-Key: ` header. 
    * Any string provided should work. 
    * In swagger UI you can use the Authorize button on the `top right`. 
    * If you want to try multi-tenancy use the key `user2` to get a different identity.
  * I designed it so that the POST on `/api/v0/patents` will answer you with your created job, for which you then have to poll the GET `/api/v0/patents/:id` endpoint for your job's completion
  * Additional Metadata, Pagination, User-friendly Error messages, Integration Tests, and such are out of scope for now
* Simulation:
  * Always finishes Jobs after 2 min (then the value is estimated to 42)
  * Quota is a sliding window of 5 tasks per 5 minutes in the simulation 
* Tests: I see that as an experiment, and thus, test coverage is not a focus at all
* Size of Patents: The Current assumption is that timeouts will work and the request body easily fits the RAM.
* Persistence of: out of scope, for now, everything just held in memory
* Testing, Linting, and generation of the mocks are not automated.
  * Testing is currently done by running 'go test ./...'
  * Linting by 'golangci-lint run'; requires 'golangci-lint'
  * The mocks are generated via 'go generate ./...'; requires mockery

# DISCLAIMER
Based on a service stub I had lying around from a hobby project